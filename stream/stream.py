import numpy as np
import cv2 
import trackpy as tp
import pims
import matplotlib.pyplot as plt
import pyautogui
from tp_plots import *  # module of modified trackpy plotting functions


def plot_vector(x_bounds:"tuple[int, int]", y_bounds:"tuple[int, int]", vector:"list[int, int]", color='b') -> None:
    """Function for plotting a magnetic vector relative to the current window size

    x_bounds: tuple of plot bounds in the form of (min, max)
    y_bounds: tuple of plot bounds in the form of (max, min)
    vector: unit vector in the form of [x, y]
    color: default color of plotted vector"""
    # print(x_bounds, y_bounds) # debugging print statement

    axis_len = None # len of shortest axis

    # checks if height < width; the shorter axis is used for subsequent calculations
    if (y_bounds[0] - y_bounds[1]) < (x_bounds[1] - x_bounds[0]):
        axis_len = y_bounds[0] - y_bounds[1]
    else:
        axis_len = x_bounds[1] - x_bounds[0]

    # Plot vector according the the shorter axis. Origin point is situated at
    # the top right of the window, offset by 1/14 of the shorter axis length.
    # Scale adjusted to be 1/25 of the shorter axis length.
    x_origin = x_bounds[1] - axis_len/14    # x coordinate of the vector's origin point
    y_origin = y_bounds[1] + axis_len/14    # y coordinate of the vector's origin point
    scale = axis_len/25 # number of data units per arrow length

    # plots vector originating from the designated origin
    plt.quiver(x_origin, y_origin, vector[0], vector[1], color=color, scale=scale)


# main script
# cap = cv.VideoCapture(0)
# if not cap.isOpened():
#     print("Cannot open camera")
#     exit()
# cv2.namedWindow("Live", cv2.WINDOW_NORMAL)
  
# Resize this window
# cv2.resizeWindow("Live", 480, 270)
# Specify resolution

  
# Specify video codec





  
# Specify frames rate. We can choose any 
# value and experiment with it

# out = cv2.VideoWriter(filename, codec, fps, resolution)


# Create an Empty window
cv2.namedWindow("Live", cv2.WINDOW_NORMAL)
  
# Resize this window
# cv2.resizeWindow("Live", 1920,)

while True:
    img = pyautogui.screenshot()
    frame = np.array(img)
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    cv2.imshow('Live', frame)
    # # Capture frame-by-frame
    # ret, frame = cap.read()
    # # if frame is read correctly ret is True
    # if not ret:
    #     print("Can't receive frame (stream end?). Exiting ...")
    #     break
    # # Our operations on the frame come here
    # gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)    # convert frame to grayscale
    # pim_gray = pims.frame.Frame(gray)   # turn grayscale into PIMS Frame object
    # f = tp.locate(pim_gray, 13, invert=True)    # get feature location DataFrame
    # fig = annotate(f, pim_gray).figure  # Get plt figure generated by trackpy's annotate

    # # remove margins and axes from figure to only get annotated figure image
    # ax = fig.gca()
    # ax.axis('off')
    # fig.tight_layout(pad=0)
    # ax.margins(0)

    # # Plot magnetic vector
    # plot_vector(x_bounds=ax.get_xlim(), y_bounds=ax.get_ylim(), vector=[1,0])

    # # Draw image onto plt canvas and convert into a numpy ndarray
    # fig.canvas.draw()
    # image_from_plot = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
    # image_from_plot = image_from_plot.reshape(fig.canvas.get_width_height()[::-1] + (3,))

    # cv.imshow('frame', image_from_plot) # show annotated image
    # fig.clear(True) # clear canvas for next preprocessed image

    # if cv.waitKey(1) == ord('q'):
    #     break  
    # Take screenshot using PyAutoGUI
    
  
    # Convert the screenshot to a numpy array
    

    
#     # Our operations on the frame come here
#     gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)    # convert frame to grayscale
#     pim_gray = pims.frame.Frame(gray)   # turn grayscale into PIMS Frame object
#     f = tp.locate(pim_gray, diameter_of_cells, minmass=1000, invert=True)    # get feature location DataFrame
#     fig = annotate(f, pim_gray).figure  # Get plt figure generated by trackpy's annotate

#     # remove margins and axes from figure to only get annotated figure image
#     ax = fig.gca()
#     ax.axis('off')
#     fig.tight_layout(pad=0)
#     ax.margins(0)

#     # Draw image onto plt canvas and convert into a numpy ndarray
#     fig.canvas.draw()
#     image_from_plot = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
#     image_from_plot = image_from_plot.reshape(fig.canvas.get_width_height()[::-1] + (3,))

#     cv.imshow('image', image_from_plot) # show annotated image
     # show annotated image
#     fig.clear(True) # clear canvas for next preprocessed image

    # if cv2.waitKey(1) == ord('q'):
    #     break
# When everything done, release the capture
# cap.release()
# cv.destroyAllWindows()